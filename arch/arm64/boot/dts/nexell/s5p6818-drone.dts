/*
 * s5p6818.dtsi - Device Tree Include file for SLsiAp SoC
 *
 * Copyright 2009 Nexell Co.
 *		http://www.nexell.co.kr
 *
 * Licensed under GPLv2 or later.
 */

/dts-v1/;
#include <dt-bindings/interrupt-controller/irq.h>
#include "s5p6818.dtsi"

#define	UART_CLOCK_FREQUENCY	147500000
#define I2C_CLOCK_FREQUENCY		100000000
#define SPI_CLOCK_FREQUENCY		100000000

#define PMIC_PDATA_INIT(_id, _rname, _minuv, _maxuv, _always_on, _boot_on,	\
						_init_uv, _init_enable, _slp_slots)					\
		regulator-name = _rname;				\
		regulator-min-microvolt = <_minuv>;		\
		regulator-max-microvolt = <_maxuv>;		\
		nx,id = <_id>;							\
		nx,always_on = <_always_on>;			\
		nx,boot_on = <_boot_on>;				\
		nx,init_enable = <_init_enable>;		\
		nx,init_uV = <_init_uv>;				\
		nx,sleep_slots = <_slp_slots>;


/ {
	memory {
		reg = <0x40000000 0x40000000>;
	};
    
	soc {
		#include "../../../../../include/nexell/target/s5p6818_drone_gpio.h"
		#include "s5p6818-pin.dtsi"

		clocks {
			uart0:uart@a9000 { clock-frequency = <UART_CLOCK_FREQUENCY>; };
			uart1:uart@a8000 { clock-frequency = <UART_CLOCK_FREQUENCY>; };
			uart2:uart@aa000 { clock-frequency = <UART_CLOCK_FREQUENCY>; };
			uart3:uart@ab000 { clock-frequency = <UART_CLOCK_FREQUENCY>; };
			uart4:uart@6e000 { clock-frequency = <UART_CLOCK_FREQUENCY>; };
			uart5:uart@84000 { clock-frequency = <UART_CLOCK_FREQUENCY>; };
			i2c0:i2c@ae000   { clock-frequency = <I2C_CLOCK_FREQUENCY>;  };
			i2c1:i2c@af000   { clock-frequency = <I2C_CLOCK_FREQUENCY>;  };
			i2c2:i2c@b0000   { clock-frequency = <I2C_CLOCK_FREQUENCY>;  };
			spi0:spi@ac000   { clock-frequency = <SPI_CLOCK_FREQUENCY>;  };
			spi1:spi@ad000   { clock-frequency = <SPI_CLOCK_FREQUENCY>;  };
			spi2:spi@a7000   { clock-frequency = <SPI_CLOCK_FREQUENCY>;  };
		};

   		dynamic-freq@bb000 {
   			supply_name  = "vdd_arm";
   			#if defined(CONFIG_REGULATOR_NXE2000) || defined(CONFIG_REGULATOR_MP8845C) || defined(CONFIG_AXP_REGULATOR)
   			vdd_arm-supply	= <&VCC1P1_ARM_PMIC>;
   			#endif
   		};

		serial@a1000 {
			dma-enable = <1>;
		};
		
		#ifdef CONFIG_MMC_NXP_CH0
		dw_mmc@62000 {
			status = "okay";
			bus_speed = <100>;
			cd_gpio = <(PAD_GPIO_C + 6)>;
			clk_dly = <0x01020000>;
		};
		#endif
		
		#ifdef CONFIG_MMC_NXP_CH1
		dw_mmc@68000 {
			status = "okay";
			bus_speed = <50>;
			cd_gpio = <(PAD_GPIO_D + 21)>;
			clk_dly = <0x01020000>;
		};
		#endif
		
		#ifdef CONFIG_MMC_NXP_CH2
		dw_mmc@69000 {
			status = "okay";
			bus_speed = <200>;
			bus_wd = <8>;
			non-removable;
			ddr-mode;
			clk_dly = <0x02030000>;
		};
		#endif

		spi@5b000 {
			#address-cells = <1>;
			#size-cells = <0>;
			num_cs = <1>;
			clk_nr = <0>;


			spidev@0 {
				compatible = "spidev";
				reg = <0>;
				spi-max-frequency = < 50000000 >;
				controller-data {
				  spi-cs-gpio = <(PAD_GPIO_C + 30)>;
					spi-feedback-delay = <02>;
					hierarchy = <0>; //0 : master, 1 : slave
				};
			};
		};
		
		rtc@10c00 {
			status = "okay";
		};

		wdt@19000 {
			status = "okay";
		};

		ppm@54000 {
			status = "okay";
		};

		framebuffer@0 {
			status = "okay";
			module = <0>;
			frame_layer = <0>;
			frame_format = <MLC_RGBFMT_A8R8G8B8>;
			back_color = <0x0>;
			bit_per_pixel	= <(4 * 8)>;
			lcd_x_resol	= <1024>;
			lcd_y_resol	= <600>;
			#ifdef CONFIG_ANDROID
			frame_buffers = <3>;
			skip_pan_vsync = <1>;
			#else
			frame_buffers = <2>;
			#endif
			lcd_with_mm	= <155>;
			lcd_height_mm = <90>;
		};

		lcd@0 {
			status = "okay";
			vsync {
				hor_active_size	= <1024>;
				hor_sync_width	= <20>;
				hor_back_porch	= <160>;
				hor_front_porch	= <160>;
				hor_sync_invert	= <1>;
				ver_active_size	= <600>;
				ver_sync_width	= <3>;
				ver_back_porch	= <23>;
				ver_front_porch	= <12>;
				ver_sync_invert	= <1>;
				pixel_clock_hz	= <(800000000/14)>;
			};
			clock {
				clock,src_div0  = <DPC_CLK_SRC_PLL2>;
				clock,div_val0	= <14>;
				clock,src_div1	= <DPC_CLK_SRC_VCLK2>;
				clock,div_val1	= <1>;
			};
		};

		pdm@14000 {
			status = "okay";
		};

		i2s_0:i2s0@55000 {
			master_mode = <1>;
			mclk_in = <0>;
			trans_mode = <1>;
			frame_bit = <48>;
			sample_rate = <48000>;
			pre_supply_mclk = <1>;
			status = "okay";
		};

		iic0:iic@a4000 {
			#address-cells = <1>;
			#size-cells = <0>;

		};

		spdiftx@59000 {
			status = "okay";
		};

		ehci@30000 {
			hsic_en = <1>;
			hsic_exthub_gpio = <159>;
		};
		
		#ifdef CONFIG_TOUCHSCREEN_GSLX680
		iic1:iic@a5000 {
			#address-cells = <1>;
			#size-cells = <0>;
			nexell,i2c-max-bus-freq = <400000>;
			gslX680@1c{
				status		= "okay";
				compatible	= "nexell,gslX680";
				reg			= <0x40>;
				mtouch-irq  = <(IRQ_GPIO_B_START+29)>;
			};
		};
		#endif

		#ifdef CONFIG_MFD_MP8845C
		iic0:iic@a4000 {
			#address-cells = <1>;
			#size-cells = <0>;

			mp8845c@1c {
				compatible = "nx,mp8845c";
				reg = <0x1c>;
				nx,id = <0>;
				#ifdef CONFIG_REGULATOR_MP8845C
				regulators {
					VCC1P1_ARM_PMIC: vout1 { PMIC_PDATA_INIT(0, "mp8845c_vout0", 600000, 1500000, 1, 1, 1200000, 1, 0xF) };
				};
				#endif
			};
		};

		iic2:iic@a6000 {
			#address-cells = <1>;
			#size-cells = <0>;
			mp8845c@1c {
				compatible = "nx,mp8845c";
				reg = <0x1c>;
				nx,id = <1>;
				#ifdef CONFIG_REGULATOR_MP8845C
				regulators {
					VCC1P0_CORE_PMIC: vout2 { PMIC_PDATA_INIT(1, "mp8845c_vout1", 600000, 1500000, 1, 1, 1100000, 1, 0xF) };
				};
				#endif
			};
		};
		#endif // CONFIG_MFD_MP8845C

		#ifdef CONFIG_MFD_NXE2000
		iic0:iic@a4000 {
			#address-cells = <1>;
			#size-cells = <0>;

			nxe2000@32 {
				compatible = "nx,nxe2000";
				reg = <0x32>;
				nx,id = <0>;
				gpios = <&gpio_alive 4 0 >; /* interrupt pin*/
				#ifdef CONFIG_REGULATOR_NXE2000
				vdd_arm-supply		= <&VCC1P1_ARM_PMIC>;
				vdd_core-supply		= <&VCC1P0_CORE_PMIC>;
				regulators {
					#ifndef CONFIG_REGULATOR_MP8845C
					VCC1P1_ARM_PMIC:	dcdc1	{ PMIC_PDATA_INIT( 0, "nxe2000_dcdc1",	 900000, 1500000, 1, 1, 1200000, 1, 0x4) };
					VCC1P0_CORE_PMIC:	dcdc2	{ PMIC_PDATA_INIT( 1, "nxe2000_dcdc2",	1000000, 1500000, 1, 1, 1100000, 1, 0x4) };
					#endif
					VCC3P3_PMIC: 		dcdc3	{ PMIC_PDATA_INIT( 2, "nxe2000_dcdc3",	1000000, 3500000, 1, 1, 3300000, 1, 0x0) };
					VCC1P5_DDR_PMIC:	dcdc4	{ PMIC_PDATA_INIT( 3, "nxe2000_dcdc4",	1000000, 2000000, 1, 1, 1500000, 1, 0xF) };
					VCC1P5_CORE_PMIC:	dcdc5	{ PMIC_PDATA_INIT( 4, "nxe2000_dcdc5",	1000000, 2000000, 1, 1, 1500000, 1, 0x4) };
					VCC_LDO1:			ldo1	{ PMIC_PDATA_INIT( 5, "nxe2000_ldo1",	1000000, 3500000, 0, 0, 3300000, 0, 0x0) };
					VCC_LDO2:			ldo2	{ PMIC_PDATA_INIT( 6, "nxe2000_ldo2",	1000000, 3500000, 0, 0, 1800000, 0, 0x0) };
					VCC1P8_CORE_PMIC:	ldo3	{ PMIC_PDATA_INIT( 7, "nxe2000_ldo3",	1000000, 3500000, 1, 1, 1800000, 1, 0x2) };
					VCC1P8_DEVICE_PMIC:	ldo4	{ PMIC_PDATA_INIT( 8, "nxe2000_ldo4",	1000000, 3500000, 1, 1, 1800000, 1, 0x2) };
					VCC_LDO5:			ldo5	{ PMIC_PDATA_INIT( 9, "nxe2000_ldo5",	1000000, 3500000, 0, 0, 2800000, 0, 0x0) };
					VCC3P3_ALV:			ldo6	{ PMIC_PDATA_INIT(10, "nxe2000_ldo6",	1000000, 3500000, 1, 1, 3300000, 1, 0xF) };
					VCC2P8_PMIC:		ldo7	{ PMIC_PDATA_INIT(11, "nxe2000_ldo7",	1000000, 3500000, 1, 1, 2800000, 1, 0x1) };
					VCC_LDO8:			ldo8	{ PMIC_PDATA_INIT(12, "nxe2000_ldo8",	1000000, 3500000, 0, 0, 3300000, 0, 0x0) };
					VCC_LDO9:			ldo9	{ PMIC_PDATA_INIT(13, "nxe2000_ldo9",	1000000, 3500000, 0, 0, 3300000, 0, 0x0) };
					VCC1P2_PMIC:		ldo10	{ PMIC_PDATA_INIT(14, "nxe2000_ldo10",	1000000, 3500000, 1, 1, 1200000, 1, 0x0) };
					VCC1P0_ALV:			ldortc1	{ PMIC_PDATA_INIT(15, "nxe2000_rtc1",	1700000, 3500000, 1, 1, 1800000, 1, 0xF) };
					VCC1P8_ALV:			ldortc2	{ PMIC_PDATA_INIT(16, "nxe2000_rtc2",	1000000, 3500000, 1, 1, 1000000, 1, 0xF) };
				};
				#endif // CONFIG_REGULATOR_NXE2000
			};
		};
		#endif // CONFIG_MFD_NXE2000

		iic3:iic@0 {
			compatible = "i2c-gpio";
			gpios = <&gpio_d 16 0		/* sda */
				&gpio_d 20 0				/* scl */
				>;
			i2c-gpio,delay-us = <10>;	/* ~100 kHz */
		};

		#ifdef CONFIG_MFD_AXP228
		iic3:iic@0 {
			#address-cells = <1>;
			#size-cells = <0>;

			axp228@34 {
				compatible = "nx,axp228";
				reg = <0x34>;
				nx,id = <0>;
				gpios = <&gpio_alive 4 0 >; /* interrupt pin*/

				#ifdef CONFIG_AXP_REGULATOR
				vdd_arm-supply = <&VCC1P1_ARM_PMIC>;
				vdd_core-supply = <&VCC1P0_CORE_PMIC>;

				regulators {
					VCC_LDO1:			axp22_rtcldo	{ PMIC_PDATA_INIT( 0, "axp228_rtcldo",		3000000, 3000000, 0, 0, 3300000, 0, 0xF) };

					VCC_LDO2:			axp22_aldo1		{ PMIC_PDATA_INIT( 1, "axp228_3p3_alive",	 700000, 3300000, 1, 1, 3300000, 1, 0xF) };
					VCC_LDO3:			axp22_aldo2		{ PMIC_PDATA_INIT( 2, "axp228_1p8_alive",	 700000, 3300000, 1, 1, 1800000, 1, 0xF) };
					VCC_LDO4:			axp22_aldo3		{ PMIC_PDATA_INIT( 3, "axp228_1p0_alive",	 700000, 3300000, 1, 1, 1000000, 1, 0xF) };

					VCC_LDO5:			axp22_dldo1		{ PMIC_PDATA_INIT( 4, "axp228_wide",			 700000, 3300000, 1, 1, 3300000, 1, 0xF) };
					VCC_LDO6:			axp22_dldo2		{ PMIC_PDATA_INIT( 5, "axp228_1p8_cam",		 700000, 3300000, 0, 0, 1800000, 0, 0xF) };
					VCC_LDO7:			axp22_dldo3		{ PMIC_PDATA_INIT( 6, "axp228_dldo3",		 700000, 3300000, 0, 0,  700000, 0, 0xF) };
					VCC_LDO8:			axp22_dldo4		{ PMIC_PDATA_INIT( 7, "axp228_dldo4",		 700000, 3300000, 0, 0,  700000, 0, 0xF) };

					VCC_LDO9:			axp22_eldo1		{ PMIC_PDATA_INIT( 8, "axp228_1p8_sys",		 700000, 3300000, 1, 1, 1800000, 1, 0xF) };
					VCC_LDO10:			axp22_eldo2		{ PMIC_PDATA_INIT( 9, "axp228_3p3_wifi",		 700000, 3300000, 1, 1, 3300000, 1, 0xF) };
					VCC_LDO11:			axp22_eldo3		{ PMIC_PDATA_INIT(10, "axp228_eldo3",		 700000, 3300000, 0, 0,  700000, 0, 0xF) };
					VCC_LDO12:			axp22_dc5ldo	{ PMIC_PDATA_INIT(11, "axp228_1p2_cvbs",		 700000, 1400000, 0, 0, 1200000, 0, 0xF) };

					VCC_DCDC1:			axp22_dcdc1		{ PMIC_PDATA_INIT(12, "axp228_3p3_sys",		1600000, 3400000, 1, 1, 3300000, 1, 0xF) };
					VCC1P1_ARM_PMIC:	axp22_dcdc2		{ PMIC_PDATA_INIT(13, "axp228_1p1_arm",		 600000, 1540000, 1, 1, 1100000, 1, 0xF) };
					VCC1P0_CORE_PMIC: 	axp22_dcdc3		{ PMIC_PDATA_INIT(14, "axp228_1p0_core",		 600000, 1860000, 1, 1, 1100000, 1, 0xF) };
					VCC_DCDC4:			axp22_dcdc4		{ PMIC_PDATA_INIT(15, "axp228_1p5_sys",		 600000, 1540000, 1, 1, 1500000, 1, 0xF) };
					VCC_DCDC5:			axp22_dcdc5		{ PMIC_PDATA_INIT(16, "axp228_1p5_ddr",		1000000, 2550000, 1, 1, 1500000, 1, 0xF) };

					VCC_LDOIO0:			axp22_ldoio0	{ PMIC_PDATA_INIT(17, "axp228_ldoio0",		 700000, 3300000, 0, 0, 1800000, 0, 0xF) };
					VCC_LDOIO1:			axp22_ldoio1	{ PMIC_PDATA_INIT(18, "axp228_ldoio1",		 700000, 3300000, 0, 0, 1000000, 0, 0xF) };
				};
				#endif // CONFIG_AXP_REGULATOR

				#ifdef CONFIG_AXP_BATTERY
				supplyer {
					nx,id = <0>;
					nx,battery_cap = <3000>;
				};
				#endif // CONFIG_AXP_BATTERY
			};
		};
		#endif // CONFIG_MFD_AXP228

		tmu-hwmon@96000 {
			polling-delay = <100>;
			trigger-step-up = <1>;
			/* overtemp, cpufreq, duration:
			  temperature less -> more, if cpufreq is zero, system poweroff */
			triggers = <
				85   800000 100
				100  400000  10
			    120       0   0
				>;
			status = "okay";
		};

		tmu-hwmon@97000 {
			polling-delay = <100>;
			trigger-step-up = <1>;
			/* overtemp, cpufreq, duration:
			  temperature less -> more, if cpufreq is zero, system poweroff */
			triggers = <
				85   800000 100
				100  400000  10
			    120       0   0
				>;
			status = "okay";
		};

		gpu@0xC0070000 {
			compatible = "arm,mali-400", "arm,mali-utgard";
			reg = <0xC0070000 0x10000>;
			interrupts = <0 72 4>, <0 72 4>, <0 72 4>, <0 72 4>, <0 72 4>, <0 72 4>, <0 72 4>, <0 72 4>, <0 72 4>, <0 72 4>, <0 72 4>;
			interrupt-names = "IRQGP", "IRQGPMMU", "IRQPP0", "IRQPPMMU0", "IRQPP1", "IRQPPMMU1", "IRQPP2", "IRQPPMMU2", "IRQPP3", "IRQPPMMU3", "IRQPMU";
			pmu_domain_config = <0x1 0x4 0x8 0x10 0x20 0x0 0x0 0x0 0x0 0x2 0x0 0x0>;
			pmu_switch_delay = <0xff>;
		};

		nxp_reset:reset@12000 {
			#reset-cells = <1>;
			compatible = "nexell,nxp-reset";
			reg = <0xC0012000 0x3>;
			status = "okay";
		};

	};	/*** soc ***/


    nxp-ion {
        compatible = "nexell,nxp-ion";
        nr = <3>;
        names = "ion_noncontig_heap", "ion_contig_heap", "nxp_contig_heap";
        types = <0 1 6>;
    };

    reserved-memory {
        #address-cells = <1>;
        #size-cells = <1>;
        ranges;

        linux,ion {
            compatible = "cma_for_ion";
            alignment= <4096>;
            size = < (192*1024*1024) >;
        };
    };  

    nxp-v4l2 {
        compatible = "nexell,nxp-v4l2";

        capture {
            nr = <2>;

            capture0 {
                module = <2>;
                type = <0>;

                port = <0>;
                external_sync = <0>;

                h_frontporch = <7>;
                h_syncwidth = <1>;
                h_backporch = <10>;
                v_frontporch = <0>;
                v_syncwidth = <2>;
                v_backporch = <3>;

                data_order = <0>;
                vid = <0>;

                interlace = <0>;
                late_power_down = <0>;

                sensor {
                    type = <0>;
                    sensor_name = "MT9D111";
                    i2c_adapter = <2>;
                    addr = <0x5d>;
                };

                power {
                    reset_io = <(PAD_GPIO_C+30)>;
                    reset_invert = <1>;
                    reset_delay_ms = <10>;
                };
            };

            capture1 {
                module = <0>;
                type = <1>;

                sensor {
                    type = <0>;
                    sensor_name = "THP7212NX";
                    i2c_adapter = <1>;
                    addr = <0x60>;
                };

                power {
                    reset_io = <(PAD_GPIO_E+16)>;
                    reset_invert = <1>;
                    reset_delay_ms = <10>;
                };
            };
        };
    };

	pdm-dir {
		compatible = "nexell,pdm-dir";
		#address-cells = <1>;
		#size-cells = <0>;
		reg = <0 0>;
	};

	pdm_recorder {
		compatible = "nexell,pdm-recorder";
		sample_rate = <48000>;
        format = "S16";
	};

	spdif-dit {
		compatible = "nexell,spdif-dit";
		#address-cells = <1>;
		#size-cells = <0>;
		reg = <0 0>;
	};

	spdif-transciever {
		compatible = "nexell,spdif-transciever";
		sample_rate = <48000>;
	    format = "S16";
	};

	spdif-dir {
		compatible = "nexell,spdif-dir";
		#address-cells = <1>;
		#size-cells = <0>;
		reg = <0 0>;
	};

	spdif-receiver {
		compatible = "nexell,spdif-receiver";
		sample_rate = <48000>;
	    format = "S16";
	};

    io-keypad {
        compatible = "nexell,nxp-keypad";
        buttons  = <
			(PAD_GPIO_ALV + 0)	116 0	/* gpio, keycode, active high */
        >;
    };

	backlight {
		compatible = "pwm-backlight";
		pwms = <&pwm_device0 0 100000>;
		pwm-names = "backlight";
        brightness-levels = <
                0 10 20 30 40
                50 60 70 80 90
                100 110 120 127
                >;
        default-brightness-level = <12>;
	};
};
